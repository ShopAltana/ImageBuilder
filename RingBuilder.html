<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="icon.png"> <!-- brouser icon -->
    <title>Image Search</title>

    <style>
        body {
            font-family: Trebuchet, sans-serif;
            background-color:  #ffb9c0;
            color: #f9f7f4;
            margin: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
          }

          h1 {
            color: #ffb9c0;
            font-size: 25px;
            font-weight: bold;
            margin-left: 27px; /* indent text block 27px*/
            margin-top: 2px; /* adjusts the top margin */
            margin-bottom: 30px; /* adjusts the bottom margin */
          }

          h2 {
            color: #da9d94;
            font-size: 15px;
            font-weight: normal;
            margin-left: 30px; /* indent text block 30px*/
            text-indent: -13px; /* pull back first line of the text block -13px to make the "list" more appealing */
            margin-top: 1px; /* adjusts the top margin */
            margin-bottom: 5px; /* adjusts the bottom margin */
          }

        a{
            color: #ffefed;
            font-size: 15px;
            font-weight: bold;
        }
        a:hover{
            color: #c7525d;
        }
        .nav-link{
            position: fixed;
            top: 20px;
            left: 5%;
            padding: 10px;
            z-index: 9999;
            text-decoration: none;
        }

          .instruction { /* What keys do what */
            flex-direction: column; /* Stacks children vertically */
            background-color:  #ffefed;
            border:5px solid #da9d94;
            border-radius: 10px;
            justify-content: center; /* Centers horizontally */
            align-items: flex-start;     /* Centers vertically */
            height: 600px;           /* Ensures the container takes the full viewport height */
            width: 300px;

            display: flex;
            gap: 0px;
          }

        .canvas-container { /* The place where you build the ring */
          display: flex;
          background-color:  #ffefed;
          border:5px solid #da9d94;
          border-radius: 15px;
          justify-content: center; /* Centers horizontally */
          align-items: center;     /* Centers vertically */
          height: 600px;           /* Ensures the container takes the full viewport height */
          width: 600px;
        }

        img { /* How do the images display on the page */
          border: 5px solid #f9f7f4; /* Adds a black border around each image */
          border-radius: 10px; /* Adds rounded corners to the border */
        }

        .app {
          display: flex;
          gap: 20px; /* space between blocks */
        }

        .sidebar {
          background-color: #ffefed;
          border: 5px solid #da9d94;
          border-radius: 15px;

          width: 150px;
          height: 570px; /* Match canvas height */
          padding: 15px;

          display: flex;
          flex-direction: column;
          gap: 10px;

          overflow-y: auto; /* Add vertical scrollbar when needed */
          overflow-x: hidden; /* Prevent horizontal scrollbar */
        }

        /* Color Swatch Styles */
        .color-swatches {
          display: flex;
          gap: 5px;
          flex-wrap: wrap;
          margin-top: 5px;
          padding: 5px;
        }

        .color-swatch {
          width: 25px;
          height: 25px;
          border: 2px solid #da9d94;
          border-radius: 5px;
          cursor: pointer;
          transition: transform 0.2s;
        }

        .color-swatch:hover {
          transform: scale(1.1);
          border-color: #ffb9c0;
        }

        .color-swatch.active {
          border: 3px solid #c7525d;
          transform: scale(1.15);
        }

        /* Material type selector */
        .material-selector {
          margin-top: 10px;
          padding: 5px;
        }

        .material-selector select {
          width: 100%;
          padding: 5px;
          border: 2px solid #da9d94;
          border-radius: 5px;
          background-color: #f1d2b3;
          font-size: 12px;
        }

        /* statistics panel */
        .stats-panel {
          background-color: #ffefed;
          border: 5px solid #da9d94;
          border-radius: 15px;

          width: 200px;
          height: 570px;
          padding: 15px;

          display: flex;
          flex-direction: column;
          gap: 10px;

          overflow-y: auto;
          overflow-x: hidden;

          font-size: 13px;
          color: #da9d94;
        }

        .stats-panel h3 {
          color: #ffb9c0;
          font-size: 18px;
          margin: 0 0 10px 0;
          font-weight: bold;
        }

        .stats-section {
          margin-bottom: 15px;
          padding-bottom: 10px;
          border-bottom: 2px solid #da9d94;
        }

        .stats-section:last-child {
          border-bottom: none;
        }

        .stat-item {
          margin: 5px 0;
          line-height: 1.4;
        }

      .menu-options {
          display: none; /* Hide the options by default */
          margin-left: 10px; /* Indent nested menus */
          cursor: pointer;
      }

      .menu-options button {
        display: block; /* Stack buttons horizontaly in sidebar*/
        margin-top: 5px; /* Add some space between the buttons */
        background-color: #f1d2b3; /* Button color */
        border: 3px solid #da9d94; /* Boarder size and color */
        border-radius: 10px; /* Give buttons a curved boarder */
        padding: 8px 12px;
        width: 100%;
        box-sizing: border-box; /* Ensures padding is included in the width */
      }

      /* Make main buttons stand out */
      .sidebar > button,
      .expandable-menu > button {
        width: 100%;
        padding: 10px;
        font-weight: bold;
        background-color: #f1d2b3;
        border: 3px solid #da9d94;
        border-radius: 10px;
      }

      /* show/hide the menu */
      .menu-options.show {
        display: block;
      }

      .expand-btn {
        cursor: pointer;
      }


    </style>
</head>

<body>
    <div class="app">
        <a href="https://shopaltana.github.io/ImageArchive/ImageArchive.html" class="nav-link">← Image Archive</a>
    </div>

  <div class="app">
    <div class="instruction">
      <h1> Instructions </h1>
      <h2> • Highlight stone before adding prongs, prongs will bind to selected stone </h2>
      <h2> • Left click to select/highlight objects </h2>
      <h2> • Hold 'Shift' to select multiple objects </h2>
      <h2> • Left click already selected object while holding 'Shift' to remove it from selection group </h2>
      <h2> • Click and drag to move objects </h2>
      <h2> • Prongs automatically move with their bound stone </h2>
      <h2> • Press 'b' to unbind selected prongs from their parent stone </h2>
      <h2> • Press 'b' to bind selected prongs to a new selected parent stone </h2>
      <h2> • Left & Right Arrowkeys to rotate highlighted object</h2>
      <h2> • Up & Down Arrowkeys to move highlighted object's layer </h2>
      <h2> • Backspace to delete highlighted object </h2>
      <h2> • + & - to scale highlighted prong size </h2>
      <h2> • Cmd C to copy highlighted objects </h2>
      <h2> • Cmd V to paste copied objects </h2>
      <h2> • Press 'x' to center highlighted objects </h2>
    </div>

    <div class="sidebar"> <!-- creating an expandable/colapsable sidebar menu -->
      <div class="expandable-menu">
        <!-- BAND MENU -->
        <button class="expand-btn">Ring Size</button>
        <div class="menu-options">
          <button class="expand-btn">Size 1</button>
          <div class="menu-options">
            <button class="expand-btn">1.6mm Wide</button>
            <div class="menu-options">
              <button onclick="addBand('RingBuilderImages/Band/S1W16H16Band.png')">1.6mm Tall</button>
              <button onclick="addBand('RingBuilderImages/Band/S1W16H17Band.png')">1.7mm Tall</button>
              <button onclick="addBand('RingBuilderImages/Band/S1W16H18Band.png')">1.8mm Tall</button>
            </div>
          </div>
          <button class="expand-btn">Size 14</button>
          <div class="menu-options">
            <button class="expand-btn">1.6mm Wide</button>
            <div class="menu-options">
              <button onclick="addBand('RingBuilderImages/Band/S14W16H16Band.png')">1.6mm Tall</button>
            </div>
          </div>
        </div>

        <!-- BAND COLOR & MATERIAL -->
        <button class="expand-btn">Band Color & Metal</button>
        <div class="menu-options">
          <div class="material-selector">
            <label style="color: #da9d94; font-size: 12px;">Metal Type:</label>
            <select id="bandMetalType">
              <option value="Yellow Gold">Yellow Gold</option>
              <option value="White Gold">White Gold</option>
              <option value="Rose Gold">Rose Gold</option>
              <option value="Platinum">Platinum</option>
              <option value="Silver">Silver</option>
            </select>
          </div>
          <div class="color-swatches" id="bandColorSwatches"></div>
        </div>

        <!-- STONE MENU -->
        <button class="expand-btn">Stones</button>
        <div class="menu-options">
            <button class="expand-btn">Round</button>
            <div class="menu-options">
                <button onclick="addStone('RingBuilderImages/Stone/0_75mmRound.png')">0.75mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/0_80mmRound.png')">0.8mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/0_85mmRound.png')">0.85mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/0_90mmRound.png')">0.9mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/0_95mmRound.png')">0.95mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/1mmRound.png')">1mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/1_5mmRound.png')">1.5mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/2mmRound.png')">2mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/2_5mmRound.png')">2.5mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/3mmRound.png')">3mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/3_5mmRound.png')">3.5mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/4mmRound.png')">4mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/4_5mmRound.png')">4.5mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/5mmRound.png')">5mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/5_5mmRound.png')">5.5mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/Rd6mm.png')">6mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/6_5mmRound.png')">6.5mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/7mmRound.png')">7mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/7_5mmRound.png')">7.5mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/8mmRound.png')">8mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/8_5mmRound.png')">8.5mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/9mmRound.png')">9mm</button>
            </div>
            <button class="expand-btn">Oval</button>
            <div class="menu-options">
                <button onclick="addStone('RingBuilderImages/Stone/Ov5x4mm.png')">5 x 4mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/6x4mmOv.png')">6 x 4mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/Ov7x5mm.png')">7 x 5mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/8x5_8mmOv.png')">8 x 5.8mm</button>
            </div>
            <button class="expand-btn">Marquise</button>
            <div class="menu-options">
                <button onclick="addStone('RingBuilderImages/Stone/6x3_5mmMrqu.png')">6 x 3.5mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/8_3x4_4mmMrqu.png')">8.3 x 4.4mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/10x5_4mmMrqu.png')">10 x 5.4mm</button>
            </div>
            <button class="expand-btn">Princess</button>
            <div class="menu-options">
                <button onclick="addStone('RingBuilderImages/Stone/3_75mmSqur.png')">3.75 x 3.75mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/4mmSqur.png')">4 x 4mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/4_3mmSqur.png')">4.3 x 4.3mm</button>
                <button onclick="addStone('RingBuilderImages/Stone/4_5mmSqur.png')">4.5 x 4.5mm</button>
            </div>
            <button class="expand-btn">Emerald</button>
            <div class="menu-options">
                <button onclick="addStone('RingBuilderImages/Stone/4_5x3mmEm.png')">4.5 x 3mm</button>
            </div>
        </div>

        <!-- STONE COLOR & TYPE -->
        <button class="expand-btn">Stone Color & Type</button>
        <div class="menu-options">
          <div class="material-selector">
            <label style="color: #da9d94; font-size: 12px;">Stone Type:</label>
            <select id="stoneType">
              <option value="Diamond">Diamond</option>
              <option value="Sapphire">Sapphire</option>
              <option value="Emerald">Emerald</option>
              <option value="Morganite">Morganite</option>
              <option value="Moissanite">Moissanite</option>
              <option value="Ruby">Ruby</option>
              <option value="Garnet">Garnet</option>
              <option value="Aquamarine">Aquamarine</option>
              <option value="Alexandrite">Alexandrite</option>
              <option value="Agate">Agate</option>
              <option value="Amethyst">Amethyst</option>
              <option value="Ametrine">Ametrine</option>
              <option value="Citrine">Citrine</option>
              <option value="Chrysoprase">Chrysoprase</option>
              <option value="Iolite">Iolite</option>
              <option value="Kunzite">Kunzite</option>
              <option value="Lapis">Lapis</option>
              <option value="Moonstone">Moonstone</option>
              <option value="Onyx">Onyx</option>
              <option value="Opal">Opal</option>
              <option value="Peridot">Peridot</option>
              <option value="Spinel">Spinel</option>
              <option value="Tanzanite">Tanzanite</option>
              <option value="Topaz">Topaz</option>
              <option value="Tourmaline">Tourmaline</option>
              <option value="Zircon">Zircon</option>
            </select>
          </div>
          <div class="color-swatches" id="stoneColorSwatches"></div>
        </div>

        <!-- PRONG MENU -->
        <button class="expand-btn">Prongs</button>
        <div class="menu-options">
          <button class="expand-btn">Round Prongs</button>
          <div class="menu-options">
            <button onclick="addProng('RingBuilderImages/Prongs/RoundProng.png')">Round Prong</button>
            <button onclick="addFourProngsAroundStone('RingBuilderImages/Prongs/RoundProng.png')">4 Round Prongs</button>
          </div>
        </div>

        <!-- PRONG COLOR & MATERIAL -->
        <button class="expand-btn">Prong Color & Metal</button>
        <div class="menu-options">
          <div class="material-selector">
            <label style="color: #da9d94; font-size: 12px;">Metal Type:</label>
            <select id="prongMetalType">
              <option value="Yellow Gold">Yellow Gold</option>
              <option value="White Gold">White Gold</option>
              <option value="Rose Gold">Rose Gold</option>
              <option value="Platinum">Platinum</option>
              <option value="Silver">Silver</option>
            </select>
          </div>
          <div class="color-swatches" id="prongColorSwatches"></div>
        </div>
      </div>
    </div>

    <div class="canvas-container">
      <canvas id="avatar" width="600" height="600"></canvas>
    </div>

    <div class="stats-panel" id="statsPanel">
      <h3>Statistics</h3>
      <div id="statsContent">
        <p>Select an object to view details</p>
      </div>
    </div>
  </div>

<script>
  const canvas = document.getElementById("avatar");
  const ctx = canvas.getContext("2d");

  // ===== COLOR MANAGEMENT =====
  let currentBandColor = '#FFD97A'; // Default: Yellow Gold
  let currentStoneColor = '#FFFFFF'; // Default: White/Diamond
  let currentProngColor = '#FFD97A'; // Default: Yellow Gold

  let currentBandMetal = 'Yellow Gold';
  let currentStoneType = 'Diamond';
  let currentProngMetal = 'Yellow Gold';

  // STONE TYPES & COLOR SUBTYPES
  const stoneColorPalettes = {
    'Diamond': [
      { color: '#FFFFFF', name: 'White' },
      { color: 'splatterLt', name: 'Light Salt & Pepper', image:'RingBuilderImages/ImageSwatches/LtSaltPepper.png' },
      { color: 'splatterDk', name: 'Dark Salt & Pepper', image:'RingBuilderImages/ImageSwatches/DkSaltPepper.png' }, 
      { color: '#171717', name: 'Black' },
      { color: '#FFE4B5', name: 'Champagne' },
      { color: '#B36C29', name: 'Cognac' },
      { color: '#FFE773', name: 'Fancy Intense Yellow' },
      { color: '#FFF5C9', name: 'Fancy Light Yellow' }
    ],
    'Sapphire': [
      { color: '#0F52BA', name: 'Blue' },
      { color: '#FFA8B7', name: 'Pink' },
      { color: '#FFA08F', name: 'Padparadscha' },
      { color: '#C1AFE3', name: 'Light Purple' },
      { color: '#624F8F', name: 'Purple' },
      { color: '#FFFFFF', name: 'White' },
      { color: '#F5D569', name: 'Yellow' },
      { color: '#F5C269', name: 'Dark Yellow' },
      { color: '#911D2B', name: 'Berry' },
      { color: '#9EBD88', name: 'Green' },
      { color: '#B1FAE0', name: 'Mint Green' },
      { color: '#165566', name: 'Moody Blue' },
      { color: '#B1EFFA', name: 'Aqua' },
      { color: 'bicolorBG', name: 'Blue-Green Bi-Colored', image:"RingBuilderImages/ImageSwatches/BlueGreenBiColor.png" }
    ],
    'Emerald': [
      { color: '#00733A', name: '' },
    ],
    'Morganite': [
      { color: '#FFEBEB', name: '' },
      { color: '#FFE8E1', name: 'Peach' }
    ],
    'Moissanite': [
      { color: '#FFFFFF', name: 'White' },
      { color: '#207B96', name: 'Blue' },
      { color: '#20967E', name: 'Green' },
      { color: '#EDE995', name: 'Yellow' },
      { color: '#E3B654', name: 'Brown' },
      { color: '#171717', name: 'Black' },
      { color: '#30C9C6', name: 'Teal' },
      { color: '#F587C5', name: 'Pink' }
    ],
    'Ruby': [
      { color: '#E30B57', name: '' },
    ],
    'Garnet': [
      { color: '#6D0909', name: 'Mozambique' },
      { color: '#5C0A1B', name: 'Rhodolite' },
      { color: '#0A5C0E', name: 'Tsavorite' },
      { color: '#FFB24A', name: 'Spessartite' },
      { color: '#4D187A', name: 'Grape' },
      { color: '#24E3CD', name: 'Paraiba Blue Yttrium Aluminium' },
      { color: '#1A1D54', name: 'Indigo Yttrium Aluminium' },
      { color: '#3DD97E', name: 'Green Yttrium Aluminium' }
    ],
    'Aquamarine': [
      { color: '#B5F3FF', name: '' }
    ],
    'Alexandrite': [
      { color: 'bicolorBP', name: '', image: 'RingBuilderImages/ImageSwatches/Alexandrite.png' }
    ],
    'Agate': [
      { color: 'mossAgate', name: 'Moss', image: 'RingBuilderImages/ImageSwatches/MossAgate.png' }
    ],
    'Amethyst': [
      { color: '#C8AFE3', name: 'Light Purple' },
      { color: '#855CB5', name: 'Purple' },
      { color: '#674091', name: 'Dark Purple' }
    ],
    'Ametrine': [
      { color: 'bicolorPO', name: '', image: 'RingBuilderImages/ImageSwatches/Ametrine.png' }
    ],
    'Citrine': [
      { color: '#FCDB95', name: '' },
      { color: '#6B2700', name: 'Madeira' }
    ],
    'Chrysoprase': [
      { color: '#C4F5D1', name: '' }
    ],
    'Iolite': [
      { color: '#2F304C', name: '' }
    ],
    'Kunzite': [
      { color: '#DEADDD', name: '' }
    ],
    'Lapis': [
      { color: 'lapis', name: '', image: 'RingBuilderImages/ImageSwatches/Lapis.png' }
    ],
    'Moonstone': [
      { color: 'moonstone', name: '', image: 'RingBuilderImages/ImageSwatches/Moonstone.png' },
      { color: 'rainbowMS', name: 'Rainbow', image: 'RingBuilderImages/ImageSwatches/RBMoonstone.png' }
    ],
    'Onyx': [
      { color: '#171717', name: '' }
    ],
    'Opal': [
      { color: 'whiteOpal', name: 'White', image: 'RingBuilderImages/ImageSwatches/whiteOpal.png' },
      { color: 'blackOpal', name: 'Black', image: 'RingBuilderImages/ImageSwatches/blackOpal.png' },
      { color: 'EthOpal', name: 'Ethiopian', image: 'RingBuilderImages/ImageSwatches/ethOpal.png' },
      { color: '#F75A00', name: 'Mexican Fire' }
    ],
    'Peridot': [
      { color: '#ACEB75', name: '' }
    ],
    'Spinel': [
      { color: '#262424', name: 'Black' },
      { color: '#FF5CA2', name: 'Pink' },
      { color: '#0F52BA', name: 'Blue' },
      { color: '#ABB9D1', name: 'Gray' }
    ],
    'Tanzanite': [
      { color: '#869EE3', name: '' }
    ],
    'Topaz': [
      { color: '#99EEFF', name: 'Swiss Blue' },
      { color: '#43899C', name: 'London Blue' },
      { color: '#A7DEEB', name: 'Sky Blue' },
      { color: '#FFFFFF', name: 'White' },
      { color: 'GnMyst', name: 'Green Mystic', image: 'RingBuilderImages/ImageSwatches/greenMystic.png' },
      { color: 'PurPinMyst', name: 'Pure Pink Mystic', image: 'RingBuilderImages/ImageSwatches/purplePinkMystic.png' },
      { color: 'SunMyst', name: 'Sunrise Mystic', image: 'RingBuilderImages/ImageSwatches/sunriseMystic.png' },
      { color: '#401D75', name: 'Violac Passion' }
    ],
    'Tourmaline': [
      { color: '#FF94BF', name: 'Pink' },
      { color: '#3B5739', name: 'Green' }
    ],
    'Zircon': [
      { color: '#30BED9', name: '' },
      { color: '#F5D94C', name: 'Yellow' }
    ],
  };

  function setBandColor(color) {
    currentBandColor = color;

    // Update metal type based on color
    const metalMap = {
      '#FFD97A': 'Yellow Gold',
      '#E8E8E6': 'White Gold',
      '#FFC299': 'Rose Gold',
      '#F1F1F1': 'Platinum',
      '#DFDFDF': 'Silver'
    };

    currentBandMetal = metalMap[color] || 'Yellow Gold';
    document.getElementById('bandMetalType').value = currentBandMetal;
      
      // Update active swatch (BAND ONLY)
      const bandSwatches = document.querySelectorAll('#bandColorSwatches .color-swatch');
      bandSwatches.forEach(swatch => {
          swatch.classList.remove('active');
          
          const swatchHex = (swatch.dataset.color || "").toLowerCase();
          if (swatchHex === color.toLowerCase()) swatch.classList.add("active");
      });
      
      const selectedBands = selectedObjects.filter(o => bands.includes(o));
      if (selectedBands.length > 0) {
          selectedBands.forEach(b => {
              b.color = color;
              b.metalType = currentBandMetal;
          });
      } else {
          currentBandColor = color;
      }
      
      renderAvatar();
  }
    function updateBandColorSwatches() {
        const bandPalette = [
            { color: '#FFD97A', name: 'Yellow Gold' },
            { color: '#E8E8E6', name: 'White Gold' },
            { color: '#FFC299', name: 'Rose Gold' },
            { color: '#F1F1F1', name: 'Platinum' },
            { color: '#DFDFDF', name: 'Silver' },
        ];
        
        const swatchContainer = document.getElementById('bandColorSwatches');
        if (!swatchContainer) return;
        
        swatchContainer.innerHTML = '';
        
        bandPalette.forEach((c) => {
            const swatch = document.createElement('div');
            swatch.className = 'color-swatch';
            swatch.style.backgroundColor = c.color;
            swatch.title = c.name;
            swatch.dataset.color = c.color;
            
            if (c.color.toLowerCase() === currentBandColor.toLowerCase()) {
                swatch.classList.add('active');
            }
            
            swatch.onclick = () => setBandColor(c.color);
            swatchContainer.appendChild(swatch);
        });
    }
    
  function setStoneColor(color) {
    currentStoneColor = color;

    // The stone type should only change via the dropdown
    // How colors update

    // Update active swatch
    const palette = stoneColorPalettes[currentStoneType] || stoneColorPalettes['Diamond'];
    const colorInfo = palette.find(c => c.color === color);
      
      // Update active swatch (STONE ONLY)
      const stoneSwatches = document.querySelectorAll('#stoneColorSwatches .color-swatch');
      stoneSwatches.forEach(swatch => swatch.classList.remove('active'));
      
      // Mark swatch as active
      stoneSwatches.forEach(swatch => {
          // If it's an image swatch, background color may be empty—so we store color in dataset
          const swatchColor = swatch.dataset.color;
          if ((swatchColor || "").toLowerCase() === color.toLowerCase()) {
              swatch.classList.add("active");
          }
      });
      
      // Update all selected stones together
      const selectedStonesList = selectedObjects.filter(o => stones.includes(o));
      if (selectedStonesList.length > 0) {
          selectedStonesList.forEach(stone => {
              stone.stoneType = currentStoneType; 
              stone.color = color;

        // Load overlay image if this color uses one
        if (colorInfo && colorInfo.image) {
          const overlayImg = new Image();
          overlayImg.src = colorInfo.image;
          overlayImg.onload = () => renderAvatar();
            overlayImg.onerror = () => {
                console.error("Failed to load overlay:", colorInfo.image);
                stone.overlayImage = null;
                renderAvatar();
            };
          stone.overlayImage = overlayImg;
        } else {
          stone.overlayImage = null;
        }
      });
    }

    renderAvatar();
  }
    
    
    function updateStoneColorSwatches(stoneType, selectedColor = null) {
        const palette = stoneColorPalettes[stoneType] || stoneColorPalettes['Diamond'];
        const swatchContainer = document.getElementById('stoneColorSwatches');
        
        if (!swatchContainer) return;
        
        // Clear existing swatches
        swatchContainer.innerHTML = '';
        
        // Decide what color should be "active"
        const desiredColor = (selectedColor ?? (palette[0]?.color ?? '')).toLowerCase();
        
        // Add new swatches
        palette.forEach((colorObj) => {
            const swatch = document.createElement('div');
            swatch.className = 'color-swatch';
            
            if (colorObj.image) {
                swatch.style.backgroundImage = `url('${colorObj.image}')`;
                swatch.style.backgroundSize = 'cover';
                swatch.style.backgroundPosition = 'center';
            } else {
                swatch.style.backgroundColor = colorObj.color;
            }
            
            swatch.title = colorObj.name;
            swatch.dataset.color = colorObj.color; 
            if ((colorObj.color || '').toLowerCase() === desiredColor) { // Set active immediately based on selectedColor
                swatch.classList.add('active');
            }
            swatch.onclick = () => setStoneColor(colorObj.color);
            swatchContainer.appendChild(swatch);
        });
        
        // Set the first color as current and update selected stone when switched
        if (palette.length > 0) {
            currentStoneColor = (selectedColor ?? palette[0].color);
            
            // If stones are selected, apply that color + overlay immediately
            const selectedStonesList = selectedObjects.filter(o => stones.includes(o));
            if (selectedStonesList.length > 0) {
                const colorInfo = palette.find(c => (c.color || '').toLowerCase() === currentStoneColor.toLowerCase());
                selectedStonesList.forEach(stone => {
                    stone.color = currentStoneColor;
                    
                    // Load overlay if swatch uses one
                    if (colorInfo && colorInfo.image) {
                      const overlayImg = new Image();
                      overlayImg.src = colorInfo.image;
                      overlayImg.onload = () => renderAvatar();
                      overlayImg.onerror = () => {
                          console.error("Failed to load overlay:", colorInfo.image);
                          stone.overlayImage = null;
                          renderAvatar();
                      };
                        stone.overlayImage = overlayImg;
                    } else {
                        stone.overlayImage = null;
                    }
                });
                renderAvatar();
            }
        }
    }


  function setProngColor(color) {
    currentProngColor = color;

    // Update metal type based on color
    const metalMap = {
      '#FFD97A': 'Yellow Gold',
      '#E8E8E6': 'White Gold',
      '#FFC299': 'Rose Gold',
      '#F1F1F1': 'Platinum',
      '#DFDFDF': 'Silver'
    };

    currentProngMetal = metalMap[color] || 'Yellow Gold';
    document.getElementById('prongMetalType').value = currentProngMetal;
      
      // Update active swatch (PRONG ONLY)
      const prongSwatches = document.querySelectorAll('#prongColorSwatches .color-swatch');
      prongSwatches.forEach(swatch => {
          swatch.classList.remove('active');
          
          const swatchHex = (swatch.dataset.color || "").toLowerCase();
          if (swatchHex === color.toLowerCase()) swatch.classList.add("active");
      });
      
      // Apply to all selected prongs
      const selectedProngs = selectedObjects.filter(o => prongs.includes(o));
      if (selectedProngs.length > 0) {
          selectedProngs.forEach(p => {
              p.color = color;
              p.metalType = currentProngMetal;
          });
      } else {
    // If no prong selected then color becomes default for new prongs
          currentProngColor = color;
      }
      
      renderAvatar();
  }
    function updateProngColorSwatches() {
        const prongPalette = [
            { color: '#FFD97A', name: 'Yellow Gold' },
            { color: '#E8E8E6', name: 'White Gold' },
            { color: '#FFC299', name: 'Rose Gold' },
            { color: '#F1F1F1', name: 'Platinum' },
            { color: '#DFDFDF', name: 'Silver' },
        ];
        
        const swatchContainer = document.getElementById('prongColorSwatches');
        if (!swatchContainer) return;
        
        swatchContainer.innerHTML = '';
        
        prongPalette.forEach((c) => {
            const swatch = document.createElement('div');
            swatch.className = 'color-swatch';
            swatch.style.backgroundColor = c.color;
            swatch.title = c.name;
            swatch.dataset.color = c.color;
            
            if (c.color.toLowerCase() === currentProngColor.toLowerCase()) {
                swatch.classList.add('active');
            }
            
            swatch.onclick = () => setProngColor(c.color);
            swatchContainer.appendChild(swatch);
        });
    }

  // Listen to dropdown changes
  document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('bandMetalType')?.addEventListener('change', (e) => {
      currentBandMetal = e.target.value;

        const reverseMetalMap = {
            'Yellow Gold': '#FFD97A',
            'White Gold':  '#E8E8E6',
            'Rose Gold':   '#FFC299',
            'Platinum':    '#F1F1F1',
            'Silver':      '#DFDFDF'
        };
        
        const newColor = reverseMetalMap[currentBandMetal];
        // If we have a known color, use setBandColor so it updates ALL selected bands
        if (newColor) {
            setBandColor(newColor);   // this already calls renderAvatar()
        } else {
            const selectedBands = selectedObjects.filter(o => bands.includes(o));
            selectedBands.forEach(b => b.metalType = currentBandMetal);
            renderAvatar();
        }
    });

    document.getElementById('stoneType')?.addEventListener('change', (e) => {
      currentStoneType = e.target.value;
        
        // Update color swatches when stone type changes
        // First swatch is active when switching types
        const palette = stoneColorPalettes[currentStoneType] || stoneColorPalettes['Diamond'];
        const firstColor = palette[0]?.color;
        updateStoneColorSwatches(currentStoneType, firstColor);

      // Update all selected stones
      const selectedStonesList = selectedObjects.filter(o => stones.includes(o));
      if (selectedStonesList.length > 0) {
        selectedStonesList.forEach(stone => {
          stone.stoneType = currentStoneType;

            // Also update the stones color to the first swatch upon changing stone type
            const palette = stoneColorPalettes[currentStoneType] || stoneColorPalettes['Diamond'];
            if (palette.length > 0) {
                stone.color = palette[0].color;

                // New color overlay image
                if (palette[0].image) {
                    const overlayImg = new Image();
                    overlayImg.src = palette[0].image;
                    overlayImg.onload = () => renderAvatar();
                    overlayImg.onerror = () => {
                        console.error("Failed to load overlay:", palette[0].image);
                        stone.overlayImage = null;
                        renderAvatar();
                    };
                    stone.overlayImage = overlayImg;
                } else {
                    stone.overlayImage = null;
                }
            }
        });
      }

      renderAvatar();
    });

    document.getElementById('prongMetalType')?.addEventListener('change', (e) => {
      currentProngMetal = e.target.value;
        
        const reverseMetalMap = {
            'Yellow Gold': '#FFD97A',
            'White Gold':  '#E8E8E6',
            'Rose Gold':   '#FFC299',
            'Platinum':    '#F1F1F1',
            'Silver':      '#DFDFDF'
        };
        
        const newColor = reverseMetalMap[currentProngMetal];
        if (newColor) {
            setProngColor(newColor);  // updates ALL selected prongs + render
        } else {
            const selectedProngs = selectedObjects.filter(o => prongs.includes(o));
            selectedProngs.forEach(p => p.metalType = currentProngMetal);
            
            renderAvatar();
        }
    });

      updateBandColorSwatches();
      updateStoneColorSwatches('Diamond', currentStoneColor);
      updateProngColorSwatches();
  });
    // Apply color tint to image (preserves transparency)
    function applyColorTint(ctx, img, x, y, width, height, color, materialType, overlayImage = null) {

    // Check if image has loaded properly
      if (!img.complete || img.naturalWidth === 0) {
          console.error("Image not loaded:", img.src);
          return; // Skip drawing broken image
      }
      
      const tempCanvas = document.createElement("canvas");
        tempCanvas.width = width;
        tempCanvas.height = height;
        const tctx = tempCanvas.getContext("2d");
        
        // Draw original image
        tctx.drawImage(img, 0, 0, width, height);
        
        // Apply color
        if (materialType === "metal") {
            // Color the metal (respecting the PNG’s shading)
            tctx.globalCompositeOperation = "overlay"; // paint only where pixels exist
            tctx.fillStyle = color;                        
            tctx.fillRect(0, 0, width, height);
        }
        
        if (materialType === "stone") {
            //Overlay image if one is present
            if (overlayImage && overlayImage.complete && overlayImage.naturalWidth > 0) {
                tctx.globalCompositeOperation = "overlay";
                tctx.drawImage(overlayImage, 0, 0, width, height);
            } else if (color && (color.startsWith('#') || color.startsWith('rgb'))) {
                
                // Color the stone (respecting the PNG’s shading)
                tctx.globalCompositeOperation = "overlay"; // paint only where pixels exist
                tctx.fillStyle = color;                     
                tctx.fillRect(0, 0, width, height);
            }
            // If color is invalid and there is no overlay image, just use original stone
        }
        
        // CRITICAL: Restore original alpha mask
        tctx.globalCompositeOperation = "destination-in";
        tctx.drawImage(img, 0, 0, width, height);
        
        // Draw final result to main canvas
        ctx.drawImage(tempCanvas, x, y);
    }


  // ===== STATE =====
  const bands = [];
  const stones = [];
  const prongs = [];

  let selectedObjects = []; // for multi selection of any element
  let selectedStone = null; // singular selected stone for prong attachment
  let activeObject = null; // for dragging

  let multiSelectMode = false; // toggled by 'Shift'

  let clipboard = {
    bands: [],
    stones: [],
    prongs: []
  };


  // ===== HELPERS =====
  function normalizeScale(img) {
    return 0.3; // Scale to fit canvas 
  }

  function updateAttachedProngs(stone) {
    prongs.forEach(prong => {
      if (prong.parentStone === stone) {
        // Apply relative angle + current stone rotation
        prong.x = stone.x + Math.cos(prong.angle + stone.rotation) * prong.radius;
        prong.y = stone.y + Math.sin(prong.angle + stone.rotation) * prong.radius;

        prong.rotation = prong.angle + stone.rotation;
      }
    });
  }
    
    function syncStoneUIToStone(stone) {
        if (!stone) return;
        
        currentStoneType = stone.stoneType;
        currentStoneColor = stone.color;
        
        const dd = document.getElementById('stoneType');
        if (dd) dd.value = currentStoneType;
        
        // Build swatches with correct active selection immediately
        updateStoneColorSwatches(currentStoneType, currentStoneColor);
    }

  function hitTestStone(x, y, stone) {
    // Transform click point into object's local space (accounting for rotation)
    const dx = x - stone.x;
    const dy = y - stone.y;

    // Rotate click point by negative object rotation
    const cos = Math.cos(-stone.rotation);
    const sin = Math.sin(-stone.rotation);
    const localX = dx * cos - dy * sin;
    const localY = dx * sin + dy * cos;

    // Test in unrotated ellipse space
    const rx = stone.radiusX * (stone.hitShrink || 1);
    const ry = stone.radiusY * (stone.hitShrink || 1);
    return (localX * localX) / (rx * rx) + (localY * localY) / (ry * ry) <= 1;
  }

  function hitTestProng(x, y, prong) {
    // Transform click point into prong's local space
    const dx = x - prong.x;
    const dy = y - prong.y;

    // Rotate click point by negative prong rotation
    const cos = Math.cos(-prong.rotation);
    const sin = Math.sin(-prong.rotation);
    const localX = dx * cos - dy * sin;
    const localY = dx * sin + dy * cos;

    const r = Math.max(6, (prong.img.naturalWidth * prong.scale) / 2);
    return localX * localX + localY * localY <= r * r;
  }

  function hitTestBand(x, y, band) {
    // Transform click point into band's local space
    const dx = x - band.x;
    const dy = y - band.y;

    // Rotate click point by negative band rotation
    const cos = Math.cos(-band.rotation);
    const sin = Math.sin(-band.rotation);
    const localX = dx * cos - dy * sin;
    const localY = dx * sin + dy * cos;

    // Test in unrotated ellipse space
    const rx = band.radiusX * (band.hitShrink || 1);
    const ry = band.radiusY * (band.hitShrink || 1);
    return (localX * localX) / (rx * rx) + (localY * localY) / (ry * ry) <= 1;
  }

    // ===== IMAGE METADATA =====
    const imageMetadata = {
        // Bands: Size format [width_mm, height_mm]
        'S1W16H16Band.png': { type: 'band', width: 1.6, height: 1.6, ringSize: 1 },
        'S1W16H17Band.png': { type: 'band', width: 1.6, height: 1.7, ringSize: 1 },
        'S1W16H18Band.png': { type: 'band', width: 1.6, height: 1.8, ringSize: 1 },
        
        'S14W16H16Band.png': { type: 'band', width: 1.6, height: 1.6, ringSize: 14 },
        
        // Stones: Size format [length_mm, width_mm, shape]
        '0_75mmRound.png': { type: 'stone', shape: 'Round', diameter: 0.75 },
        '0_80mmRound.png': { type: 'stone', shape: 'Round', diameter: 0.8 },
        '0_85mmRound.png': { type: 'stone', shape: 'Round', diameter: 0.85 },
        '0_90mmRound.png': { type: 'stone', shape: 'Round', diameter: 0.9 },
        '0_95mmRound.png': { type: 'stone', shape: 'Round', diameter: 0.95 },
        '1mmRound.png': { type: 'stone', shape: 'Round', diameter: 1 },
        '1_5mmRound.png': { type: 'stone', shape: 'Round', diameter: 1.5 },
        '2mmRound.png': { type: 'stone', shape: 'Round', diameter: 2 },
        '2_5mmRound.png': { type: 'stone', shape: 'Round', diameter: 2.5 },
        '3mmRound.png': { type: 'stone', shape: 'Round', diameter: 3 },
        '3_5mmRound.png': { type: 'stone', shape: 'Round', diameter: 3.5 },
        '4mmRound.png': { type: 'stone', shape: 'Round', diameter: 4 },
        '4_5mmRound.png': { type: 'stone', shape: 'Round', diameter: 4.5 },
        '5mmRound.png': { type: 'stone', shape: 'Round', diameter: 5 },
        '5_5mmRound.png': { type: 'stone', shape: 'Round', diameter: 5.5 },
        'Rd6mm.png': { type: 'stone', shape: 'Round', diameter: 6 },
        '6_5mmRound.png': { type: 'stone', shape: 'Round', diameter: 6.5 },
        '7mmRound.png': { type: 'stone', shape: 'Round', diameter: 7 },
        '7_5mmRound.png': { type: 'stone', shape: 'Round', diameter: 7.5 },
        '8mmRound.png': { type: 'stone', shape: 'Round', diameter: 8 },
        '8_5mmRound.png': { type: 'stone', shape: 'Round', diameter: 8.5 },
        '9mmRound.png': { type: 'stone', shape: 'Round', diameter: 9 },

        'Ov5x4mm.png': { type: 'stone', shape: 'Oval', length: 5, width: 4 },
        '6x4mmOv.png': { type: 'stone', shape: 'Oval', length: 6, width: 4 },
        'Ov7x5mm.png': { type: 'stone', shape: 'Oval', length: 7, width: 5 },
        '8x5_8mmOv.png': { type: 'stone', shape: 'Oval', length: 8, width: 5.8 },

        '6x3_5mmMrqu.png': { type: 'stone', shape: 'Marquise', length: 6, width: 3.5 },
        '8_3x4_4mmMrqu.png': { type: 'stone', shape: 'Marquise', length: 8.3, width: 4.4 },
        '10x5_4mmMrqu.png': { type: 'stone', shape: 'Marquise', length: 10, width: 5.4 },

        '3_75mmSqur.png': { type: 'stone', shape: 'Princess', length: 3.75, width: 3.75 },
        '4mmSqur.png': { type: 'stone', shape: 'Princess', length: 4, width: 4 },
        '4_3mmSqur.png': { type: 'stone', shape: 'Princess', length: 4.3, width: 4.3 },
        '4_5mmSqur.png': { type: 'stone', shape: 'Princess', length: 4.5, width: 4.5 },

        '4_5x3mmEm.png': { type: 'stone', shape: 'Emerald', length: 4.5, width: 3 },
        
        // Prongs
        'RoundProng.png': { type: 'prong', shape: 'Round' }
    };

    // Helper function to get metadata from image source
    function getImageMetadata(imgSrc) {
      const filename = imgSrc.split('/').pop().split('?')[0]; // Remove path and cache-busting
      return imageMetadata[filename] || null;
    }


   // ===== GLOBAL SCENE SCALE =====
   let sceneScale = 1; // 1 = current size, <1 smaller, >1 larger

  // ===== BAND =====
  function createBand(src) {
    const img = new Image();
    img.src = src;

    const band = {
      img,
      x: canvas.width / 2,
      y: canvas.height / 2,
      scale: 1,
      rotation: 0,
      zIndex: bands.length,
      color: currentBandColor,
      metalType: currentBandMetal
    };

    img.onload = () => {
      band.scale = normalizeScale(img);
      band.radiusX = (img.naturalWidth * band.scale) / 2;
      band.radiusY = (img.naturalHeight * band.scale) / 2;
      band.hitShrink = 1;
      renderAvatar();
    };

    return band;
  }

  function addBand(src) {
    bands.push(createBand(src));
  }

  // ===== STONES =====
  function createStone(src) {
    const img = new Image();
    img.src = src;

    const stone = {
      img,
      x: canvas.width / 2,
      y: canvas.height / 2,
      scale: 1,
      rotation: 0,
      zIndex: stones.length,
      color: currentStoneColor,
      stoneType: currentStoneType,
      overlayImage: null // allows for "image based" color swatches
    };

    //checks if color swatch has an image overlay
    const palette = stoneColorPalettes[currentStoneType] || stoneColorPalettes['Diamond'];
    const colorInfo = palette.find(c => c.color === currentStoneColor);

    if (colorInfo && colorInfo.image) {
      const overlayImg = new Image();
      overlayImg.src = colorInfo.image;
        overlayImg.onload = () => renderAvatar();
        overlayImg.onerror = () => {
            console.error("Failed to overlay image:", colorInfo.image);
            stone.overlayImage = null;
            renderAvatar();
        };
        stone.overlayImage = overlayImg;
    }
      
      img.onload = () => {
      stone.scale = normalizeScale(img);

      // Stone shape/radious is elipse not square image box
      stone.radiusX = (img.naturalWidth * stone.scale) / 2;
      stone.radiusY = (img.naturalHeight * stone.scale) / 2;

      //Clickable area of the stone is 100% of its radious
      stone.hitShrink = 1;

      // Base size for proportional scaleing of other eliments
      stone.visualHeight = img.naturalHeight * stone.scale;
      renderAvatar();
    };

      img.onerror = () => {
          console.error("Failed to load stone image:", src);
      };
      
      return stone;
  }

  function addStone(src) {
    stones.push(createStone(src));
  }

  // ===== UPDATE STATS PANEL =====
  function updateStatsPanel() {
    const statsContent = document.getElementById('statsContent');
    let html = '';

    // BANDS SECTION
    if (bands.length > 0) {
      html += `<div class="stats-section"><strong>Band${bands.length > 1 ? 's' : ''}:</strong><br>`;

      // Group bands by unique metadata
      const bandGroups = {};
      bands.forEach(band => {
        const metadata = getImageMetadata(band.img.src);
        if (metadata) {
          const key = `${metadata.ringSize}-${metadata.width}-${metadata.height}-${band.metalType}`;
          if (!bandGroups[key]) {
            bandGroups[key] = { count: 0, metadata, metalType: band.metalType };
          }
          bandGroups[key].count++;
        }
      });

      Object.values(bandGroups).forEach(group => {
        const m = group.metadata;
        html += `<div class="stat-item">(${group.count}) Size ${m.ringSize}, ${m.width}mm W x ${m.height}mm H<br>`;
        html += `<span style="margin-left: 15px; color: #c7525d;">${group.metalType}</span></div>`;
      });

      html += '</div>';
    }

    // STONES SECTION
    if (stones.length > 0) {
      html += `<div class="stats-section"><strong>Stone${stones.length > 1 ? 's' : ''}:</strong><br>`;

      stones.forEach((stone, index) => {
        const metadata = getImageMetadata(stone.img.src);

        if (metadata) {
          // Get color name from the palette
          const palette = stoneColorPalettes[stone.stoneType] || stoneColorPalettes['Diamond'];
          const colorInfo = palette.find(c => (c.color || '').toLowerCase() === (stone.color || '').toLowerCase());
          const colorName = colorInfo ? colorInfo.name : 'Unknown';

          if (metadata.diameter) {
            html += `<div class="stat-item">${metadata.shape} ${metadata.diameter}mm<br>`;
          } else {
            html += `<div class="stat-item">${metadata.shape} ${metadata.length} x ${metadata.width}mm<br>`;
          }
          html += `<span style="margin-left: 15px; color: #c7525d;">${colorName} ${stone.stoneType}</span></div>`;
        }
        // Prongs attached to this stone
        const attachedProngs = prongs.filter(p => p.parentStone === stone);
        if (attachedProngs.length > 0) {
          html += `<div class="stat-item" style="margin-left: 15px;"><strong>Prongs:</strong></div>`;

          // Group prongs by size and type
          const prongGroups = {};
          attachedProngs.forEach(p => {
            const prongMetadata = getImageMetadata(p.img.src);
            const sizeMM = (p.img.naturalWidth * p.scale * 0.0442).toFixed(2); //adjust prong size
            const shape = prongMetadata ? prongMetadata.shape : 'Unknown';
            const key = `${shape}-${sizeMM}-${p.metalType}`;

            if (!prongGroups[key]) {
              prongGroups[key] = { count: 0, shape, sizeMM, metalType: p.metalType };
            }
            prongGroups[key].count++;
          });

          Object.values(prongGroups).forEach(group => {
            html += `<div class="stat-item" style="margin-left: 30px;">(${group.count}) ${group.shape} ${group.sizeMM}mm<br>`;
              html += `<span style="margin-left: 45px; color: #c7525d;">${group.metalType}</span></div>`;
          });
        }
      });

      // Unattached prongs
      const unattached = prongs.filter(p => !p.parentStone);
      if (unattached.length > 0) {
        html += `<div class="stat-item"><br><strong>Unattached Prongs: ${unattached.length}</strong></div>`;

        const prongGroups = {};
        unattached.forEach(p => {
          const prongMetadata = getImageMetadata(p.img.src);
          const sizeMM = (p.img.naturalWidth * p.scale * 0.0442).toFixed(2);
          const shape = prongMetadata ? prongMetadata.shape : 'Unknown';
          const key = `${shape}-${sizeMM}-${p.metalType}`;

          if (!prongGroups[key]) {
            prongGroups[key] = { count: 0, shape, sizeMM, metalType: p.metalType };
          }
          prongGroups[key].count++;
        });

        Object.values(prongGroups).forEach(group => {
          html += `<div class="stat-item" style="margin-left: 15px;">(${group.count}) ${group.shape} ${group.sizeMM}mm<br>`;
            html += `<span style="margin-left: 45px; color: #c7525d;">${group.metalType}</span></div>`;
        });
      }

      html += '</div>';
    }

    // Show message if nothing on canvas
    if (bands.length === 0 && stones.length === 0 && prongs.length === 0) {
      html = '<p>No items on canvas</p>';
    }

    statsContent.innerHTML = html;
  }

  // ===== PRONGS =====
  function addProng(src) {
      const parent = selectedStone || null; // allows for valid unattached prongs
      const baseZ = parent ? parent.zIndex + 1 : prongs.length;
    }

    const img = new Image();
    img.src = src;

    img.onload = () => {
      const targetProngSizeMM = 1.0; // Prong size, First render size fixed to 1mm
      const prongScale = targetProngSizeMM /(img.naturalWidth * 0.0442); // scale prong mm to pixles

      const prong = {
        img,
        x: (parent ? parent.x : canvas.width / 2), //position at center x (of canvas or parent stone)
        y: (parent ? parent.y : canvas.height / 2), //position at center y (of canvas or parent stone)
        scale: prongScale,
        rotation: 0, // defaut rotation 0 degrees
        zIndex: baseZ,
        parentStone: parent, // bind prong to selected stone if one is selected but allows for unattached prongs
        radius: 0, //prong polar coordinates at stone center
        angle: 0,
        color: currentProngColor,
        metalType: currentProngMetal
      };

      prongs.push(prong);
      renderAvatar();
    };
  }

  // ===== RENDER =====
  function renderAvatar() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // === GLOBAL SCENE SCALE (applies to EVERYTHING) ===
    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.scale(sceneScale, sceneScale);
    ctx.translate(-canvas.width / 2, -canvas.height / 2);

    // === Bands (bottom) ===
    bands
      .sort((a, b) => a.zIndex - b.zIndex)
      .forEach(band => {
        ctx.save();
        ctx.translate(band.x, band.y);
        ctx.rotate(band.rotation);
        ctx.scale(band.scale, band.scale);

        // Apply color tint
        const x = -band.img.naturalWidth / 2;
        const y = -band.img.naturalHeight / 2;
        applyColorTint(ctx, band.img, x, y, band.img.naturalWidth, band.img.naturalHeight, band.color, "metal");


        // BAND SELECTION HIGHLIGHT
        if (selectedObjects.includes(band)) {
            const highlightCanvas = document.createElement("canvas");
            highlightCanvas.width = band.img.naturalWidth;
            highlightCanvas.height = band.img.naturalHeight;
            const hctx = highlightCanvas.getContext("2d");

            hctx.drawImage(band.img, 0, 0); // Draw base image

            // Apply swatch color tint (purly asthetcs)
            hctx.globalCompositeOperation = "overlay";
            hctx.fillStyle = band.color;
            hctx.fillRect(0, 0, highlightCanvas.width, highlightCanvas.height);

            // Restore alpha mask
            hctx.globalCompositeOperation = "destination-in";
            hctx.drawImage(band.img, 0, 0);

            // Apply highlight on top of swatch colored image (purly for asthetics)
            hctx.globalCompositeOperation = "source-in";
            hctx.fillStyle = "#da9d9440";
            hctx.fillRect(0, 0, highlightCanvas.width, highlightCanvas.height);

            ctx.drawImage(highlightCanvas, -band.img.naturalWidth / 2, -band.img.naturalHeight / 2);
        }
        ctx.restore();
      });

    // === Stones (middle) ===
    stones
      .sort((a, b) => a.zIndex - b.zIndex)
      .forEach(stone => {
        ctx.save();
        ctx.translate(stone.x, stone.y);
        ctx.rotate(stone.rotation);
        ctx.scale(stone.scale, stone.scale);

        // Apply color tint (with overlay image if available)
        const x = -stone.img.naturalWidth / 2;
        const y = -stone.img.naturalHeight / 2;
        applyColorTint(ctx, stone.img, x, y, stone.img.naturalWidth, stone.img.naturalHeight, stone.color, "stone", stone.overlayImage);

        // STONE SELECTION HIGHLIGHT (source-in)
        if (selectedObjects.includes(stone)) {
            const highlightCanvas = document.createElement("canvas");
            highlightCanvas.width = stone.img.naturalWidth;
            highlightCanvas.height = stone.img.naturalHeight;
            const hctx = highlightCanvas.getContext("2d");

            hctx.drawImage(stone.img, 0, 0);

            // Apply hex or image overlay
            if (stone.overlayImage && stone.overlayImage.complete && stone.overlayImage.naturalWidth > 0) {
                hctx.globalCompositeOperation = "overlay";
                hctx.drawImage(stone.overlayImage, 0, 0, highlightCanvas.width, highlightCanvas.height);
            } else if (stone.color && (stone.color.startsWith('#') || stone.color.startsWith('rgb'))) {
                hctx.globalCompositeOperation = "overlay";
                hctx.fillStyle = stone.color;
                hctx.fillRect(0, 0, highlightCanvas.width, highlightCanvas.height);
            }

            // Restore alpha mask
            hctx.globalCompositeOperation = "destination-in";
            hctx.drawImage(stone.img, 0, 0);

            // source-in highlight
            hctx.globalCompositeOperation = "source-in"; // ignores "empty" pixel space
            hctx.fillStyle = "#da9d9440"; // highlight color
            hctx.fillRect(0, 0, highlightCanvas.width, highlightCanvas.height);

            ctx.drawImage(highlightCanvas, -stone.img.naturalWidth / 2, -stone.img.naturalHeight / 2);
        }

        ctx.restore();
      });

    // === Prongs (top) ===
    prongs
      .sort((a, b) => a.zIndex - b.zIndex)
      .forEach(prong => {
        ctx.save();
        ctx.translate(prong.x, prong.y);
        ctx.rotate(prong.rotation);
        ctx.scale(prong.scale, prong.scale);

        // Apply color tint
        const x = -prong.img.naturalWidth / 2;
        const y = -prong.img.naturalHeight / 2;
        applyColorTint(ctx, prong.img, x, y, prong.img.naturalWidth, prong.img.naturalHeight, prong.color, "metal");

        // PRONG SELECTION HIGHLIGHT
        if (selectedObjects.includes(prong)) {
            const highlightCanvas = document.createElement("canvas");
            highlightCanvas.width = prong.img.naturalWidth;
            highlightCanvas.height = prong.img.naturalHeight;
            const hctx = highlightCanvas.getContext("2d");

            hctx.drawImage(prong.img, 0, 0);

            hctx.globalCompositeOperation = "overlay";
            hctx.fillStyle = prong.color;
            hctx.fillRect(0, 0, highlightCanvas.width, highlightCanvas.height);

            hctx.globalCompositeOperation = "destination-in";
            hctx.drawImage(prong.img, 0, 0);

            hctx.globalCompositeOperation = "source-in";
            hctx.fillStyle = "#da9d9440";
            hctx.fillRect(0, 0, highlightCanvas.width, highlightCanvas.height);

            ctx.drawImage(highlightCanvas, -prong.img.naturalWidth / 2, -prong.img.naturalHeight / 2);
        }
        ctx.restore();
      });

    // === END GLOBAL SCENE SCALE ===
    ctx.restore();
    updateStatsPanel();
  }

      // Multiple autimatic prongs
      function addFourProngsAroundStone(prongSrc) {
        const stone = selectedStone;
        if (!stone) return;

        const rx = stone.radiusX;
        const ry = stone.radiusY;

        const inset = 0.02; // 2% inward

        const angles = [
          Math.PI / 4,        // top-right
          (3 * Math.PI) / 4,  // top-left
          (5 * Math.PI) / 4,  // bottom-left
          (7 * Math.PI) / 4   // bottom-right
        ];

        angles.forEach(angle => {
          const img = new Image();
          img.src = prongSrc;

          img.onload = () => {

            const targetProngSizeMM = 1.0; // Initial prong render fixed to 1mm
            const prongScale = targetProngSizeMM / (img.naturalWidth * 0.0442);

            const prong = {
              img,
              scale: prongScale,
              rotation: angle, // initial rotation
              zIndex: stone.zIndex + 1,
              parentStone: stone,
              angle: angle, // Polar coordinates relative to stone
              color: currentProngColor,
              metalType: currentProngMetal
            };

            // initial placement // -inset moves position in (2%)
            prong.x = stone.x + Math.cos(angle) * rx * (1 - inset);
            prong.y = stone.y + Math.sin(angle) * ry * (1 - inset);

            // STORE RELATIVE POSITION (RUN ONCE)
            const dx = prong.x - stone.x;
            const dy = prong.y - stone.y;

            prong.radius = Math.sqrt(dx * dx + dy * dy);
            prong.angle = Math.atan2(dy, dx) - stone.rotation;

            prong.rotation = prong.angle;

            prongs.push(prong);
            renderAvatar();
          };
        }); // closes angles.forEach
      }   // closes addFourProngsAroundStone


  // ===== OBJECT INTERACTION =====
  let dragOffsetX = 0;
  let dragOffsetY = 0;

  canvas.addEventListener("mousedown", e => {
    if (e.detail > 1) return; // ignore double-click
    let clickedObject = false;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
      
      
      // Check objects from top layer to bottom ( prongs > stone > band )
      const hitList = [...prongs, ...stones, ...bands].sort((a,b) => b.zIndex - a.zIndex);
      
      for (const obj of hitList) {
          let hit = false;
          if (prongs.includes(obj)) hit = hitTestProng(x,y,obj);
          else if (stones.includes(obj)) hit = hitTestStone(x,y,obj);
          else hit = hitTestBand(x,y,obj);
          
          if (hit) {
              activeObject = obj;
              dragOffsetX = x - obj.x;
              dragOffsetY = y - obj.y;

        // Multi-select mode: toggle selection
        if (multiSelectMode) {
          // If already selected remove the object from selection
          const index = selectedObjects.indexOf(obj);
          if (index > -1) {
            selectedObjects.splice(index, 1); // remove object from selection
          } else {
            selectedObjects.push(obj); // add object to selection
          }
        } else {
          // Otherwise add the object to selection
          if (!selectedObjects.includes(obj)) {
            selectedObjects = [obj];
          }
        }
          
          // Stone selection for prong attachment
          if (stones.includes(obj)) {
              selectedStone = obj;
              syncStoneUIToStone(obj);
          }
          
          clickedObject = true;
          break;
      }
    }

    if (!clickedObject) {
      selectedObjects = [];
      selectedStone = null;
      activeObject = null;
    }

    renderAvatar();
  });

  canvas.addEventListener("mousemove", e => {
  if (!activeObject) return;

  const rect = canvas.getBoundingClientRect();
  const newX = e.clientX - rect.left;
  const newY = e.clientY - rect.top;

  // Calculate movement delta
  const deltaX = newX - dragOffsetX - activeObject.x;
  const deltaY = newY - dragOffsetY - activeObject.y;

  // Move ALL selected objects together
  selectedObjects.forEach(obj => {
    obj.x += deltaX;
    obj.y += deltaY;

    // Update attached prongs for stones
    if (stones.includes(obj)) {
      updateAttachedProngs(obj);
    }
  });

  renderAvatar();
});

  canvas.addEventListener("mouseup", () => {
    if (activeObject && prongs.includes(activeObject)) {
      const stone = activeObject.parentStone;
      if (stone) {
        const dx = activeObject.x - stone.x;
        const dy = activeObject.y - stone.y;

        activeObject.radius = Math.sqrt(dx * dx + dy * dy);
        activeObject.angle = Math.atan2(dy, dx) - stone.rotation;
      }
    }

    activeObject = null;

  });

  document.addEventListener("keydown", e => {
    const isCmdOrCtrl = e.metaKey || e.ctrlKey;

    //  multi-select with Shift
    if (e.key === "Shift") multiSelectMode = true;

    // ===== BIND/UNBIND PRONGS (press 'b') =====
    if (e.key.toLowerCase() === "b") {
      const selectedProngsList = selectedObjects.filter(o => prongs.includes(o));
      const selectedStonesList = selectedObjects.filter(o => stones.includes(o));

      if (selectedProngsList.length > 0) {
        // If we have a selected prong and selected stone, bind the prong to the stone
        if (selectedStonesList.length === 1) {
          const targetStone = selectedStonesList[0];

          selectedProngsList.forEach(prong => {
            prong.parentStone = targetStone;

          // Calculate relative prong position to stone
          const dx = prong.x - targetStone.x;
          const dy = prong.y - targetStone.y;
          prong.radius = Math.sqrt(dx * dx + dy * dy);
          prong.angle = Math.atan2(dy, dx) - targetStone.rotation;
        });

        console.log(`Bound ${selectedProngsList.length} prong(s) to new parent stone(s)`);
      }
      // If only prong selected, unbind the prong
      else {
        selectedProngsList.forEach(prong => {
          prong.parentStone = null; // Unbind from parent stone
        });
        console.log(`Unbound ${selectedProngsList.length} prong(s) from their parent stone(s)`);
      }

        renderAvatar();
        e.preventDefault();
      }
    }

    // ===== COPY (Cmd/Ctrl + C) =====
    if (isCmdOrCtrl && e.key.toLowerCase() === "c") {
      // Copy active object (band, stone, or prong)
      clipboard.bands = [];
      clipboard.stones = [];
      clipboard.prongs = [];

      // Copy all selected objects
      selectedObjects.forEach(obj => {
        if (bands.includes(obj)) { // copy bands
          clipboard.bands.push({
            x: obj.x,
            y: obj.y,
            scale: obj.scale,
            rotation: obj.rotation,
            zIndex: obj.zIndex,
            imgSrc: obj.img.src,
            radiusX: obj.radiusX,
            radiusY: obj.radiusY,
            hitShrink: obj.hitShrink,
            color: obj.color,
            metalType: obj.metalType
          });
        } else if (stones.includes(obj)) { // Copy stones
          clipboard.stones.push({
            x: obj.x,
            y: obj.y,
            scale: obj.scale,
            rotation: obj.rotation,
            zIndex: obj.zIndex,
            imgSrc: obj.img.src,
            radiusX: obj.radiusX,
            radiusY: obj.radiusY,
            visualHeight: obj.visualHeight,
            hitShrink: obj.hitShrink,
            color: obj.color,
            stoneType: obj.stoneType
          });
        } else if (prongs.includes(obj)) { // Copy prongs
            const selectedStonesList = selectedObjects.filter(o => stones.includes(o));
            clipboard.prongs.push({
                x: obj.x,
                y: obj.y,
                scale: obj.scale,
                rotation: obj.rotation,
                imgSrc: obj.img.src,
                radius: obj.radius,
                angle: obj.angle,
                color: obj.color,
                metalType: obj.metalType,
                parentStoneIndex: obj.parentStone ? selectedStonesList.indexOf(obj.parentStone) : -1
            });
        }
      })

      // Copy prongs attached to selected stones
      const selectedStonesList = selectedObjects.filter(o => stones.includes(o));
      prongs.forEach(p => {
        if (p.parentStone && selectedStonesList.includes(p.parentStone) && !selectedObjects.includes(p)) {
          clipboard.prongs.push({
            x: p.x,
            y: p.y,
            scale: p.scale,
            rotation: p.rotation,
            imgSrc: p.img.src,
            radius: p.radius,
            angle: p.angle,
            color: p.color,
            metalType: p.metalType,
            parentStoneIndex: p.parentStone ? selectedStonesList.indexOf(p.parentStone) : -1
          })
        }
      });

      e.preventDefault();
      console.log("Copied:", clipboard);
    }

    // ===== PASTE (Cmd/Ctrl + V) =====
    if (isCmdOrCtrl && e.key.toLowerCase() === "v") {
      // Paste bands
      const newBands = clipboard.bands.map(orig => {
        const img = new Image();
        img.src = orig.imgSrc;

        const band = {
          img,
          x: orig.x + 20,
          y: orig.y + 20,
          scale: orig.scale,
          rotation: orig.rotation,
          zIndex: bands.length,
          radiusX: orig.radiusX,
          radiusY: orig.radiusY,
          hitShrink: orig.hitShrink,
          color: orig.color,
          metalType: orig.metalType,

        };

        bands.push(band);
        return band;
      });

      // Paste stones
        const newStones = clipboard.stones.map(orig => {
            const img = new Image();
            img.src = orig.imgSrc;
            
            const stone = {
                img,
                x: orig.x + 20,
                y: orig.y + 20,
                scale: orig.scale,
                rotation: orig.rotation,
                zIndex: stones.length,
                radiusX: orig.radiusX,
                radiusY: orig.radiusY,
                visualHeight: orig.visualHeight,
                hitShrink: orig.hitShrink,
                color: orig.color,
                stoneType: orig.stoneType,
                overlayImage: null
            };
            
            const palette = stoneColorPalettes[stone.stoneType] || stoneColorPalettes['Diamond'];
            const colorInfo = palette.find(c =>
                (c.color || '').toLowerCase() === (stone.color || '').toLowerCase()
                                          );
            
            if (colorInfo && colorInfo.image) {
                const overlayImg = new Image();
                overlayImg.src = colorInfo.image;
                overlayImg.onload = () => renderAvatar();
                overlayImg.onerror = () => {
                    console.error("Failed to load overlay:", colorInfo.image);
                    stone.overlayImage = null;
                    renderAvatar();
                };
                stone.overlayImage = overlayImg;
            } else {
                stone.overlayImage = null;
            }
            
            stones.push(stone);
            return stone;
        });

      // Paste prongs
      const newProngs = clipboard.prongs.map(orig => {
        const img = new Image();
        img.src = orig.imgSrc;

        // Check if prong has a parent stone reference
        const parentStone = orig.parentStoneIndex >= 0 ? newStones[orig.parentStoneIndex] : null;

        const prong = {
          img,
          x: orig.x + 20,
          y: orig.y + 20,
          scale: orig.scale,
          rotation: orig.rotation,
          zIndex: parentStone ? parentStone.zIndex + 1 : prongs.length,
          parentStone: parentStone,
          radius: orig.radius,
          angle: orig.angle,
          color: orig.color,
          metalType: orig.metalType

        };

        // If has parent stone, recalculate position
        if (parentStone) {
          prong.x = parentStone.x + prong.radius * Math.cos(prong.angle + parentStone.rotation);
          prong.y = parentStone.y + prong.radius * Math.sin(prong.angle + parentStone.rotation);
        }

        prongs.push(prong);
        return prong;
      });

      // Select newly pasted items
      const newObjects = [...newBands, ...newStones, ...newProngs];
      selectedObjects = newObjects;
      if (newStones.length > 0) {
        selectedStone = newStones[0];
      }

      renderAvatar();
      e.preventDefault();
    }

    // ===== CENTER SELECTED OBJECT (press 'x') =====
    if (e.key.toLowerCase() === "x" && selectedObjects.length > 0) {
      selectedObjects.forEach(obj => {
        obj.x = canvas.width / 2;
        obj.y = canvas.height / 2;

        if (stones.includes(obj)) updateAttachedProngs(obj);
      });

      // Deselect after centering to prevent dragging jitter
      selectedObjects = [];
      selectedStone = null;
      activeObject = null;

      renderAvatar();
      e.preventDefault();
    }

    // ===== OBJECT TRANSFORMS =====

    // Scale prongs (single or multiple)
    if (e.key === "+" || e.key === "=" || e.key === "-" || e.key === "_") {
      const prongsToScale = selectedObjects.filter(o => prongs.includes(o));

    // Scale prongs
    if (prongsToScale.length > 0) {
      const SCALE_INCREMENT_MM = 0.05; // 0.05mm increments
      const CONVERSION_FACTOR = 0.0442; // pixel to mm conversion

      prongsToScale.forEach(prong => {
        if (e.key === "+" || e.key === "=") {
          const currentSizeMM = prong.img.naturalWidth * prong.scale * CONVERSION_FACTOR; // Calculate current mm size from initial px size
          const newSizeMM = currentSizeMM + SCALE_INCREMENT_MM; // increase size by 0.05mm
          prong.scale = newSizeMM / (prong.img.naturalWidth * CONVERSION_FACTOR); // Convert new mm size back to px
          prong.scale = Math.round(prong.scale * 10000) / 10000; // round to prevent drift from decimals
        }
        if (e.key === "-" || e.key === "_") {
          const currentSizeMM = prong.img.naturalWidth * prong.scale * CONVERSION_FACTOR; // Calculate current mm size from initial px size
          const newSizeMM = Math.max(0.3, currentSizeMM - SCALE_INCREMENT_MM); // decrese size by 0.05mm, minimum prong size 0.3mm
          prong.scale = newSizeMM / (prong.img.naturalWidth * CONVERSION_FACTOR); // Convert new mm size back to px
          prong.scale = Math.round(prong.scale * 10000) / 10000; // round to prevent drift from decimals
        }
      });

      renderAvatar();
      e.preventDefault();
      return; // size transformation is only for prongs
    }
  }

  // Rotate all selected objects
  if (e.key === "ArrowRight") {
    selectedObjects.forEach(obj => {
      obj.rotation += Math.PI / 16;
      if (stones.includes(obj)) updateAttachedProngs(obj);
    });
    renderAvatar();
    e.preventDefault(); // Prevent page scroll
  }

  if (e.key === "ArrowLeft") {
    selectedObjects.forEach(obj => {
      obj.rotation -= Math.PI / 16;
      if (stones.includes(obj)) updateAttachedProngs(obj);
    });
    renderAvatar();
    e.preventDefault(); // Prevent page scroll
  }

  // Move layer for all selected objects
  if (e.key === "ArrowUp") {
    selectedObjects.forEach(obj => obj.zIndex++);
    renderAvatar();
    e.preventDefault(); // Prevent page scroll
  }

  if (e.key === "ArrowDown") {
    selectedObjects.forEach(obj => obj.zIndex--);
    renderAvatar();
    e.preventDefault(); // Prevent page scroll
  }

  // Delete all selected objects
  if (e.key === "Backspace") {
    selectedObjects.forEach(obj => {
      let list;
      if (prongs.includes(obj)) list = prongs;
      else if (stones.includes(obj)) list = stones;
      else list = bands;

      const idx = list.indexOf(obj);
      if (idx > -1) list.splice(idx, 1);
    });

    selectedObjects = [];
    activeObject = null;
    renderAvatar();
    e.preventDefault(); // Prevent browser back navigation
  }
});

  document.addEventListener("keyup", e => {
    if (e.key === "Shift") multiSelectMode = false; // release Shift to exit multi-select
  });

  canvas.addEventListener("dblclick", e => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    selectedStone = null;

    // topmost stone wins
    const sortedStones = [...stones].sort(
      (a, b) => b.zIndex - a.zIndex
    );

    for (const stone of sortedStones) {
        if (hitTestStone(x, y, stone)) {
            selectedStone = stone;
            break;
        }
    }

    renderAvatar();
  });

  // ===== MENUS =====
  document.querySelectorAll(".expand-btn").forEach(btn => {
      const menu = btn.nextElementSibling;
      if (!menu || !menu.classList.contains("menu-options")) return;
      
    btn.addEventListener("click", () => {
        menu.classList.toggle("show");
    });
  });

</script>
</body>
</html>
